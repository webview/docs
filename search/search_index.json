{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"WebView A tiny cross-platform webview library to create a common HTML5 UI abstraction layer frontend with your favorite programming language as the backend! This library is written in C/C++ and has bindings for many others. See the sidebar for an API reference in each specific language. It supports two-way JavaScript bindings (to call JavaScript from the backend-language and to call the backend-language from JavaScript). It uses Cocoa/WebKit on macOS, gtk-webkit2 on Linux and Edge on Windows 10. Dependencies Windows Windows 10 SDK via Visual Studio Installer C++ support via Visual Studio Installer See Microsoft Docs for more info Ubuntu sudo apt install webkit2gtk-4.0 Try webkit2gtk-4.0-dev if webkit2gtk-4.0 is not found OpenBSD requires wxallowed mount(8) option FreeBSD pkg install webkit2-gtk3 MacOS Just build it!","title":"WebView"},{"location":"#webview","text":"A tiny cross-platform webview library to create a common HTML5 UI abstraction layer frontend with your favorite programming language as the backend! This library is written in C/C++ and has bindings for many others. See the sidebar for an API reference in each specific language. It supports two-way JavaScript bindings (to call JavaScript from the backend-language and to call the backend-language from JavaScript). It uses Cocoa/WebKit on macOS, gtk-webkit2 on Linux and Edge on Windows 10.","title":"WebView"},{"location":"#dependencies","text":"Windows Windows 10 SDK via Visual Studio Installer C++ support via Visual Studio Installer See Microsoft Docs for more info Ubuntu sudo apt install webkit2gtk-4.0 Try webkit2gtk-4.0-dev if webkit2gtk-4.0 is not found OpenBSD requires wxallowed mount(8) option FreeBSD pkg install webkit2-gtk3 MacOS Just build it!","title":"Dependencies"},{"location":"alternatives/","text":"Alternatives to WebView When it comes to creating a desktop app with a web frontend, there are many options outside WebView. See an extensive list of Electron alternatives here: https://github.com/sudhakar3697/electron-alternatives Don't Make a Desktop App A good portion of WebView apps could have been much better as web apps or browser extensions. Please consider this as you research what library is best for you. Non HTML/CSS/JS Frameworks Chances are, HTML/CSS/JS is not the right choice for your app, especially if it's a tool (designed to do one thing). Using HTML/CSS/JS as your frontend can be justified when your frontend is bigger than your backend. GTK LCUI Qt ncurses Chrome/Chromium Rendering Backend Using Chrome/Chromium as a web backend is very useful, since most people have it installed, and know how to install it. https://github.com/zserge/lorca https://github.com/pojala/electrino WebView Compatible Libraries https://github.com/jchv/go-webview2 Android WebView doesn't officially support android, but it's not too hard to get a webview up and running there. - https://github.com/petabyt/ndkhellohtml - https://github.com/petabyt/gowebview Watching https://github.com/alifcommunity/webui","title":"Alternatives"},{"location":"alternatives/#alternatives-to-webview","text":"When it comes to creating a desktop app with a web frontend, there are many options outside WebView. See an extensive list of Electron alternatives here: https://github.com/sudhakar3697/electron-alternatives","title":"Alternatives to WebView"},{"location":"alternatives/#dont-make-a-desktop-app","text":"A good portion of WebView apps could have been much better as web apps or browser extensions. Please consider this as you research what library is best for you.","title":"Don't Make a Desktop App"},{"location":"alternatives/#non-htmlcssjs-frameworks","text":"Chances are, HTML/CSS/JS is not the right choice for your app, especially if it's a tool (designed to do one thing). Using HTML/CSS/JS as your frontend can be justified when your frontend is bigger than your backend. GTK LCUI Qt ncurses","title":"Non HTML/CSS/JS Frameworks"},{"location":"alternatives/#chromechromium-rendering-backend","text":"Using Chrome/Chromium as a web backend is very useful, since most people have it installed, and know how to install it. https://github.com/zserge/lorca https://github.com/pojala/electrino","title":"Chrome/Chromium Rendering Backend"},{"location":"alternatives/#webview-compatible-libraries","text":"https://github.com/jchv/go-webview2","title":"WebView Compatible Libraries"},{"location":"alternatives/#android","text":"WebView doesn't officially support android, but it's not too hard to get a webview up and running there. - https://github.com/petabyt/ndkhellohtml - https://github.com/petabyt/gowebview","title":"Android"},{"location":"alternatives/#watching","text":"https://github.com/alifcommunity/webui","title":"Watching"},{"location":"about/license/","text":"WebView is licensed under the MIT License. You can see more info here . This website is licensed under the Mit License. You can find and contribute to the source here .","title":"License"},{"location":"bindings/c/","text":"Building For a full example showing how to compile your C backend alongside WebView, see our webview_c repository. See https://github.com/webview/webview/blob/master/webview.h#L37 for the built in C API.","title":"C"},{"location":"bindings/c/#building","text":"For a full example showing how to compile your C backend alongside WebView, see our webview_c repository. See https://github.com/webview/webview/blob/master/webview.h#L37 for the built in C API.","title":"Building"},{"location":"bindings/cpp/","text":"API webview::webview Creates a new webview instance. If debug is non-zero - developer tools will be enabled (if the platform supports them). Window parameter can be a pointer to the native window handle. If it's non-null - then child WebView is embedded into the given parent window. Otherwise a new window is created. Depending on the platform, a GtkWindow, NSWindow or HWND pointer can be passed here. webview(bool debug = false, void *wnd = nullptr) webview::set_title Updates the title of the native window. Must be called from the UI thread. void set_title(const std::string title) webview::set_size Accepts a WEBVIEW_HINT . #define WEBVIEW_HINT_NONE 0 #define WEBVIEW_HINT_MIN 1 #define WEBVIEW_HINT_MAX 2 #define WEBVIEW_HINT_FIXED 3 void set_size(int width, int height, int hints) webview::navigate Navigates webview to the given URL. URL may be a data URI, i.e. \"data:text/text, ... \". It is often ok not to url-encode it properly, webview will re-encode it for you. void navigate(const std::string url) webview::run Runs the main loop until it's terminated. After this function exits - you must destroy the webview. void run() webview::eval Evaluates arbitrary JavaScript code. Evaluation happens asynchronously, also the result of the expression is ignored. Use the bind function if you want to receive notifications about the results of the evaluation. void eval(const std::string js) webview::init Injects JavaScript code at the initialization of the new page. Every time the webview will open a the new page - this initialization code will be executed. It is guaranteed that code is executed before window.onload. void init(const std::string js) webview::bind Binds a native C++ callback so that it will appear under the given name as a global JavaScript function. Internally it uses init . Callback receives a request string. Request string is a JSON array of all the arguments passed to the JavaScript function. void bind(const std::string name, sync_binding_t fn) sync_binding_t is an alias for std::function<std::string(std::string)> Thus, an example callback looks like: std::string myBoundCallback(string args) { return \"\\\"Return this string to the JS function 'myBoundCallback'\\\"\"; } Now you can call this JavaScript function like so: myBoundCallback(\"arg1\", 2, true).then(e => console.log(e)); webview::resolve Used to return a string value from the native binding. This function is used internally when a return value is present in a bound callback as in the example above. You can also use this function directly: The seq number must be provided to match requests with responses. If status is zero - result is expected to be a valid JSON result value. If status is not zero - result is an error JSON object. void resolve(const std::string seq, int status, const std::string result) webview::unbind Removes a native C++ callback that was previously set by bind . void unbind(const std::string name) webview::window Returns a pointer to the platform-specific window. You must cast from void * to the proper type. void *window() webview::terminate Closes the webview window. void terminate() webview::dispatch Posts a function to be executed on the main thread. You normally do not need to call this function, unless you want to tweak the native window. void dispatch(std::function<void()> f) Compiling Linux c++ main.cc `pkg-config --cflags --libs gtk+-3.0 webkit2gtk-4.0` -o webview-example MacOS c++ main.cc -std=c++11 -framework WebKit -o webview-example Windows (x64) script/build.bat The webview.exe file will be in the build directory. Examples Hello World: #include \"webview.h\" int main() { webview::webview w(true, nullptr); w.set_title(\"Minimal example\"); w.set_size(480, 320, WEBVIEW_HINT_NONE); w.navigate(\"https://en.m.wikipedia.org/wiki/Main_Page\"); w.run(); return 0; } Complex Example: #include \"webview.h\" #include <iostream> int main() { webview::webview w(true, nullptr); w.set_title(\"Example\"); w.set_size(480, 320, WEBVIEW_HINT_NONE); w.set_size(180, 120, WEBVIEW_HINT_MIN); w.bind(\"noop\", [](std::string s) -> std::string { std::cout << s << std::endl; return s; }); w.bind(\"add\", [](std::string s) -> std::string { auto a = std::stoi(webview::json_parse(s, \"\", 0)); auto b = std::stoi(webview::json_parse(s, \"\", 1)); return std::to_string(a + b); }); w.navigate(R\"V0G0N(data:text/html, <!doctype html> <html> <body>hello</body> <script> window.onload = function() { document.body.innerText = `hello, ${navigator.userAgent}`; noop('hello').then(function(res) { console.log('noop res', res); }); add(1, 2).then(function(res) { console.log('add res', res); }); }; </script> </html> )V0G0N\"); w.run(); return 0; }","title":"C++"},{"location":"bindings/cpp/#api","text":"","title":"API"},{"location":"bindings/cpp/#webviewwebview","text":"Creates a new webview instance. If debug is non-zero - developer tools will be enabled (if the platform supports them). Window parameter can be a pointer to the native window handle. If it's non-null - then child WebView is embedded into the given parent window. Otherwise a new window is created. Depending on the platform, a GtkWindow, NSWindow or HWND pointer can be passed here. webview(bool debug = false, void *wnd = nullptr)","title":"webview::webview"},{"location":"bindings/cpp/#webviewset_title","text":"Updates the title of the native window. Must be called from the UI thread. void set_title(const std::string title)","title":"webview::set_title"},{"location":"bindings/cpp/#webviewset_size","text":"Accepts a WEBVIEW_HINT . #define WEBVIEW_HINT_NONE 0 #define WEBVIEW_HINT_MIN 1 #define WEBVIEW_HINT_MAX 2 #define WEBVIEW_HINT_FIXED 3 void set_size(int width, int height, int hints)","title":"webview::set_size"},{"location":"bindings/cpp/#webviewnavigate","text":"Navigates webview to the given URL. URL may be a data URI, i.e. \"data:text/text, ... \". It is often ok not to url-encode it properly, webview will re-encode it for you. void navigate(const std::string url)","title":"webview::navigate"},{"location":"bindings/cpp/#webviewrun","text":"Runs the main loop until it's terminated. After this function exits - you must destroy the webview. void run()","title":"webview::run"},{"location":"bindings/cpp/#webvieweval","text":"Evaluates arbitrary JavaScript code. Evaluation happens asynchronously, also the result of the expression is ignored. Use the bind function if you want to receive notifications about the results of the evaluation. void eval(const std::string js)","title":"webview::eval"},{"location":"bindings/cpp/#webviewinit","text":"Injects JavaScript code at the initialization of the new page. Every time the webview will open a the new page - this initialization code will be executed. It is guaranteed that code is executed before window.onload. void init(const std::string js)","title":"webview::init"},{"location":"bindings/cpp/#webviewbind","text":"Binds a native C++ callback so that it will appear under the given name as a global JavaScript function. Internally it uses init . Callback receives a request string. Request string is a JSON array of all the arguments passed to the JavaScript function. void bind(const std::string name, sync_binding_t fn) sync_binding_t is an alias for std::function<std::string(std::string)> Thus, an example callback looks like: std::string myBoundCallback(string args) { return \"\\\"Return this string to the JS function 'myBoundCallback'\\\"\"; } Now you can call this JavaScript function like so: myBoundCallback(\"arg1\", 2, true).then(e => console.log(e));","title":"webview::bind"},{"location":"bindings/cpp/#webviewresolve","text":"Used to return a string value from the native binding. This function is used internally when a return value is present in a bound callback as in the example above. You can also use this function directly: The seq number must be provided to match requests with responses. If status is zero - result is expected to be a valid JSON result value. If status is not zero - result is an error JSON object. void resolve(const std::string seq, int status, const std::string result)","title":"webview::resolve"},{"location":"bindings/cpp/#webviewunbind","text":"Removes a native C++ callback that was previously set by bind . void unbind(const std::string name)","title":"webview::unbind"},{"location":"bindings/cpp/#webviewwindow","text":"Returns a pointer to the platform-specific window. You must cast from void * to the proper type. void *window()","title":"webview::window"},{"location":"bindings/cpp/#webviewterminate","text":"Closes the webview window. void terminate()","title":"webview::terminate"},{"location":"bindings/cpp/#webviewdispatch","text":"Posts a function to be executed on the main thread. You normally do not need to call this function, unless you want to tweak the native window. void dispatch(std::function<void()> f)","title":"webview::dispatch"},{"location":"bindings/cpp/#compiling","text":"","title":"Compiling"},{"location":"bindings/cpp/#linux","text":"c++ main.cc `pkg-config --cflags --libs gtk+-3.0 webkit2gtk-4.0` -o webview-example","title":"Linux"},{"location":"bindings/cpp/#macos","text":"c++ main.cc -std=c++11 -framework WebKit -o webview-example","title":"MacOS"},{"location":"bindings/cpp/#windows-x64","text":"script/build.bat The webview.exe file will be in the build directory.","title":"Windows (x64)"},{"location":"bindings/cpp/#examples","text":"Hello World: #include \"webview.h\" int main() { webview::webview w(true, nullptr); w.set_title(\"Minimal example\"); w.set_size(480, 320, WEBVIEW_HINT_NONE); w.navigate(\"https://en.m.wikipedia.org/wiki/Main_Page\"); w.run(); return 0; } Complex Example: #include \"webview.h\" #include <iostream> int main() { webview::webview w(true, nullptr); w.set_title(\"Example\"); w.set_size(480, 320, WEBVIEW_HINT_NONE); w.set_size(180, 120, WEBVIEW_HINT_MIN); w.bind(\"noop\", [](std::string s) -> std::string { std::cout << s << std::endl; return s; }); w.bind(\"add\", [](std::string s) -> std::string { auto a = std::stoi(webview::json_parse(s, \"\", 0)); auto b = std::stoi(webview::json_parse(s, \"\", 1)); return std::to_string(a + b); }); w.navigate(R\"V0G0N(data:text/html, <!doctype html> <html> <body>hello</body> <script> window.onload = function() { document.body.innerText = `hello, ${navigator.userAgent}`; noop('hello').then(function(res) { console.log('noop res', res); }); add(1, 2).then(function(res) { console.log('add res', res); }); }; </script> </html> )V0G0N\"); w.run(); return 0; }","title":"Examples"}]}